<!DOCTYPE html>
<html>
<head>
   <link rel=stylesheet href="http://codemirror.net/lib/codemirror.css">
   <link rel=stylesheet href="http://codemirror.net/theme/solarized.css">
   <script src="http://codemirror.net/lib/codemirror.js"></script>
   <script src="http://codemirror.net/mode/ruby/ruby.js"></script>
   <style>
     body, html, .content, .CodeMirror {
       margin:  0;
       padding: 0;
       width:  100%;
       height: 100%;
     }

     .currentElement {
       background-color: #00495b; /* solarized dark (#002b36) times 1.7 */
     }

     .CodeMirror {
       padding-top: 1em;
     }
   </style>
</head>

<body>
  <div class="content">
    <div class="stats">
      <div class="time"></div>
      <div class="correct"></div>
      <div class="incorrect"></div>
    </div>
    <textarea class="code"><%= @game.fetch(:body) %></textarea>
  </div>

  <script>
    window.game = (function() {
      'use strict';

      var SyntaxSpray = {};

      // =====  StatsView  =====
      SyntaxSpray.StatsView = function(domElement) {
        this.domElement   = domElement;
        this.domCorrect   = domElement.getElementsByClassName('correct')[0];
        this.domIncorrect = domElement.getElementsByClassName('incorrect')[0];
        this.domTime      = domElement.getElementsByClassName('time')[0];
      }

      SyntaxSpray.StatsView.prototype.init = function() {
        this.updateDuration(0);
        this._numCorrect = -1;
        this.incrementCorrect();
        this._numIncorrect = -1;
        this.incrementIncorrect();
      }

      SyntaxSpray.StatsView.prototype.updateDuration = function(secondsElapsed) {
        this.domTime.textContent = this.formatDuration(secondsElapsed);
      }

      SyntaxSpray.StatsView.prototype.formatDuration = function(secondsElapsed) {
        var minutes = parseInt(secondsElapsed / 60);
        var seconds = secondsElapsed % 60;
        return "" + minutes + ":" + (seconds > 9 ? parseInt(seconds / 10) : "0") + (seconds % 10); // JS apparently has no sprintf or rjust
      }

      SyntaxSpray.StatsView.prototype.incrementCorrect = function() {
        this._numCorrect++;
        this.domCorrect.textContent = this._numCorrect;
      }

      SyntaxSpray.StatsView.prototype.incrementIncorrect = function() {
        this._numIncorrect++;
        this.domIncorrect.textContent = this._numIncorrect;
      }

      // =====  TraverseAst  =====
      SyntaxSpray.TraverseAst = function(ast, cb) {
        this.ast = ast;
        this._cb = cb;
      }
      SyntaxSpray.TraverseAst.prototype.successor = function() {
        if(this.ast.children.length == 0) return (this._cb||function(){})();
        return this.ast.children.reduceRight(
          function(cb, childAst) {
            return function() { return new SyntaxSpray.TraverseAst(childAst, cb) };
          },
          this._cb
        )()
      }

      // =====  Game  =====
      SyntaxSpray.Game = function(attrs) {
        var game         = this;
        this._traverse   = new SyntaxSpray.TraverseAst(attrs.ast)
        this._statsView  = attrs.statsView;
        this._codeMirror = attrs.codeMirror;
        this._keyMap     = attrs.keyMap;
      }

      SyntaxSpray.Game.prototype.init = function() {
        this._initCodeMirror();
        this._statsView.init();
      }

      SyntaxSpray.Game.prototype.start = function(getTime, setInterval) {
        this._currentElement = this._codeMirror.markText({line:0, ch:0},{line:0,ch:5},{className: "currentElement"});
        var statsView = this._statsView;
        var startTime = this._startTime = getTime();
        setInterval(function() {
          var milliseconds = getTime() - startTime;
          var seconds      = parseInt(milliseconds / 1000);
          statsView.updateDuration(seconds);
        }, 1000);
      }

      SyntaxSpray.Game.prototype.finish = function() {
        console.log("FINISHED!");
      }

      SyntaxSpray.Game.prototype.pressKey = function(key) {
        var selectedType = this._keyMap[key];
        var type         = this._traverse.ast.type
        if(selectedType == type) {
          this._statsView.incrementCorrect();
          this._currentElement.clear();
          this._traverse = this._traverse.successor();
          if(this._traverse) {
            var ast = this._traverse.ast;
            this._currentElement = this._codeMirror.markText(
              {line: ast.begin_line, ch: ast.begin_col},
              {line: ast.end_line,   ch: ast.end_col},
              {className: "currentElement"}
            );
          } else {
            this.finish();
          }
        } else {
          this._statsView.incrementIncorrect();
        }
      }

      SyntaxSpray.Game.prototype._initCodeMirror = function() {
        // seriously no clue why the interface works this way, it makes no sense to me, and took me forever to figure out >.<
        var game       = this;
        var cmKeyMap   = {call: function(key) { return function() { game.pressKey(key); return "handled"; }}}; // can also return "multi"
        var codeMirror = this._codeMirror;
        codeMirror.setOption("readOnly",                true);
        codeMirror.setOption("cursorBlinkRate",         -1); // hides the cursor
        codeMirror.setOption("disableInput",            true);
        codeMirror.setOption("showCursorWhenSelecting", false);
        codeMirror.setOption("keyMap",                  cmKeyMap);
      }


      // =====  Wire it all together  =====
      var game = new SyntaxSpray.Game({
        codeMirror: CodeMirror.fromTextArea(
                      document.getElementsByTagName('textarea')[0],
                      {lineNumbers: true, theme: 'solarized dark', autofocus: true}
                    ),
        statsView:  new SyntaxSpray.StatsView(document.getElementsByClassName('stats')[0]),
        ast:        <%= @game.fetch :json_ast %>,
        keyMap:     { S: "send",
                      I: "int",
                    },
      });

      game.init();
      return game;
    })();

    game.start(function() { return new Date() }, setInterval);
  </script>
</div>
</body>
</html>
